"use strict";
const BaseError = require("./base-error");
class ValidationError extends BaseError {
  constructor(message, errors, options) {
    super(message);
    this.name = "SequelizeValidationError";
    this.message = "Validation Error";
    this.errors = errors || [];
    if (message) {
      this.message = message;
    } else if (this.errors.length > 0 && this.errors[0].message) {
      this.message = this.errors.map((err) => `${err.type || err.origin}: ${err.message}`).join(",\n");
    }
    if (options && options.stack) {
      this.stack = options.stack;
    }
  }
  get(path) {
    return this.errors.reduce((reduced, error) => {
      if (error.path === path) {
        reduced.push(error);
      }
      return reduced;
    }, []);
  }
}
class ValidationErrorItem {
  constructor(message, type, path, value, instance, validatorKey, fnName, fnArgs) {
    this.message = message || "";
    this.type = null;
    this.path = path || null;
    this.value = value !== void 0 ? value : null;
    this.origin = null;
    this.instance = instance || null;
    this.validatorKey = validatorKey || null;
    this.validatorName = fnName || null;
    this.validatorArgs = fnArgs || [];
    if (type) {
      if (ValidationErrorItem.Origins[type]) {
        this.origin = type;
      } else {
        const lowercaseType = `${type}`.toLowerCase().trim();
        const realType = ValidationErrorItem.TypeStringMap[lowercaseType];
        if (realType && ValidationErrorItem.Origins[realType]) {
          this.origin = realType;
          this.type = type;
        }
      }
    }
  }
  getValidatorKey(useTypeAsNS, NSSeparator) {
    const useTANS = useTypeAsNS === void 0 || !!useTypeAsNS;
    const NSSep = NSSeparator === void 0 ? "." : NSSeparator;
    const type = this.origin;
    const key = this.validatorKey || this.validatorName;
    const useNS = useTANS && type && ValidationErrorItem.Origins[type];
    if (useNS && (typeof NSSep !== "string" || !NSSep.length)) {
      throw new Error("Invalid namespace separator given, must be a non-empty string");
    }
    if (!(typeof key === "string" && key.length)) {
      return "";
    }
    return (useNS ? [type, key].join(NSSep) : key).toLowerCase().trim();
  }
}
ValidationErrorItem.Origins = {
  CORE: "CORE",
  DB: "DB",
  FUNCTION: "FUNCTION"
};
ValidationErrorItem.TypeStringMap = {
  "notnull violation": "CORE",
  "string violation": "CORE",
  "unique violation": "DB",
  "validation error": "FUNCTION"
};
module.exports = ValidationError;
module.exports.ValidationErrorItem = ValidationErrorItem;
//# sourceMappingURL=validation-error.js.map
